Here's a quick proposal for the API for rpi/micro communication.
I'll probably begin writing the python for outbound tomorrow or Sunday,
and write a quick "response server" in another day or two, so we can test
the web interface.

Required communication from micro:
--Piece Commands
- piece placed
- piece type
- piece location
- ports at location
- resources on location
- roll of resources
- if valid
--Turn Commands
- Resources Recieved by Player 

There are a few different responses that could occur:
- road placed:
{ "command":"piece", "piece":"new", "piecetype":"road", "pieceloc":"D,3", "locresources":[ { "resource":"wheat", "roll":11, "scarcity":3 }, { "resource":"ore", "roll":4, "scarcity":2 } ], "locports":null, "isvalid":true }
- settlement placed:
{ "command":"piece", "piece":"new", "piecetype":"town", "pieceloc":"A,2", "locresources":[ { "resource":"wheat", "roll":4, "scarcity":5 }, {"resource":"ore", "roll":3, "scarcity": 3}, {"resource":"wood", "roll":4, "scarcity":6 } ], "locports":null, "isvalid":true }
- city placed:
{ "command":"piece", "piece":"replace", "piecetype":"town", "pieceloc":"B,1", "locresources":[ {"resource":"wood", "roll":2, "scarcity":4 }, {"resouce":"sheep", "roll":12, "scarcity":4}], "locports":{"type":"any", "value":4}, "isvalid":false }
- settlement removed (to be replaced by a city):
{ "command":"piece", "piece":"removed", "piecetype":"town", "pieceloc":"A,2", "locresources":[ { "resource":"wheat", "roll":4, "scarcity":5 }, {"resource":"ore", "roll":3, "scarcity": 3}, {"resource":"wood", "roll":4, "scarcity":6 } ], "locports":null, "isvalid":true}
- Thief placed:
{ "command":"piece", "piece":"new", "piecetype":"thief", "pieceloc":"B,3", "locresources":[ { "resource":"desert", "roll":0, "scarcity":0 } ], "locports":null, "isvalid":true }
- Turn change, dice rolled:
{ "command":"turn", "resources":[ {"player":1, "recieved":[ { "resource":"wheat", "amount":1 }, {"resource":"ore", "amount":2} ]}, {"player":2, "recieved":null}, {"player":3, "recieved":[ {"resource":"sheep", "amount":1}]}]}

--The specifics are:
 - "piece": "new" for a new placement (road, settlement), "replace" for a replaced placement (city), or "removed" for a removed piece (invalid move or settlement). "replace" can also be used to replace a piece that was not validly moved.
 - "piecetype": "road" for a road, "town" for a settlement or city. The game can't distinguish between the two on it's own, except for removals and replacements, but without feedback from the pi, it can't be certain whether the removal was due to an invalid move or not. While it will be receiving data from the pi for either scenario, it will probably be easier not to try to keep track of this on the micro itself.
 - "pieceloc": A coordinate pair referring to the piece location. I used the Letter,Number system as an example, and it's my recommendation, though any easily parsed system will work.
 - "locresrouces": An array of objects, each containing the following elements:
   . "resource" : The resource at a neighboring hex. Can be "wood", "wheat", "ore", "sheep", "brick", or "desert".
   . "roll" : The number that needs to be rolled in order to retreive this resource. Should be 0 for the desert.
   . "scarcity" : The relative scarcity of the resource. Should be 0 for the desert. I don't know the specifics of how these are defined, so I used random numbers.
 - "locports": Either null if the piece is not adjacent to any ports, or an object containing the following:
   . "type" : The type of resource that can be traded at this port. Can be "wood", "wheat", "ore", "sheep", "brick", or "any".
	. "value" : The exchange rate. Since all rates are of the form X:1, only the X is required. Typical values are 2,3,4.

All responses from the micro should follow the same general format for ease of packing for communication on the micro itself to the pi. This includes adding seemingly useless information, such as nearby resources for a road. However, this is just a proposal. If anyone has a better idea, now's a good time to hear it. Additionally, responses from the pi to the micro should follow one of two formats: system command or board command. Again this is for ease of parsing on the micro. System command will be commands for the board to do something, such as notifying of an invalid move, rolling a die, perform fancy effect A, etc. Board commands will deal with the board itself, and may also initiate system commands of their own accord (that is, even though a system command isn't sent, it may do something a system command would normally do). This would include things like place a settlement, move the thief, etc. Generally, board commands will be primarily for the microcontroller to keep track of game state, while system commands will generally be used to control the LEDs and 7Segs. However, a board command could also change the state of the LEDs, for example, "move the thief" could light the hex the thief is on until it is removed, then return lighting to it's normal form (lighting resources), then dim the LED lights when the thief is placed, except for the one the thief is placed on, until a user hits "OK" on the web interface, when the board returns to normal state.

...I'm too verbose.

Required communication to micro:
---Board commands
   --Town purchased
   --Road Purchased
   --Move Thief
---System Commands
   --Roll Dice
   --Invalid Command (placing or removing piece)
	--Turn end

Some examples:
{ "command":"board", "type":"purchase", "piece":"town"}
{ "command":"board", "type":"purchase", "piece":"road"}
{ "command":"board", "type":"thief"}
{ "command":"system", "type":"roll", "result":{3,4} }
{ "command":"system", "type":"invalid"}
{ "command":"system", "type":"turn"}

This is much simpler than the communication from the micro to the pi, as the micro does not require information about the economy.
